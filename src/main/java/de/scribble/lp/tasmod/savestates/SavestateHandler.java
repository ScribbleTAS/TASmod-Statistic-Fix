package de.scribble.lp.tasmod.savestates;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.logging.FileHandler;

import javax.annotation.Nullable;

import org.apache.commons.io.FileUtils;

import com.google.common.io.Files;

import de.scribble.lp.tasmod.CommonProxy;
import de.scribble.lp.tasmod.ModLoader;
import de.scribble.lp.tasmod.savestates.exceptions.SavestateException;
import de.scribble.lp.tasmod.tickratechanger.TickrateChangerServer;
import net.minecraft.client.Minecraft;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.world.chunk.storage.AnvilChunkLoader;

/**
 * New and improved savestatehandler. Creates and loads savestates on both client and server without closing the world <br>
 * The old version of this was heavily inspired by bspkrs' <a href="https://www.curseforge.com/minecraft/mc-mods/worldstatecheckpoints">WorldStateCheckpoints</a>, but I can honestly say now
 * that I replaced everything that mod had with new things. This also makes savestates without closing the server...
 * 
 * @author ScribbleLP
 *
 */
public class SavestateHandler {
	private static MinecraftServer server=ModLoader.getServerInstance();
	private static final File savestateDirectory=new File(server.getDataDirectory()+File.separator+"saves"+File.separator+"savestates"+File.separator);
	
	public static boolean isSaving=false;
	
	public static boolean isLoading=false;
	
	public static void saveState() throws SavestateException, IOException {
		if(isSaving) {
			throw new SavestateException("A savestating operation is already being carried out");
		}
		if(isLoading) {
			throw new SavestateException("A loadstate operation is being carried out");
		}
		isSaving=true;
		
		createSavestateDirectory();
		
		if(server.isDedicatedServer()) {
			TickrateChangerServer.changeServerTickrate(0);
			TickrateChangerServer.changeClientTickrate(0);
		}
		
		CommonProxy.NETWORK.sendToAll(new SavestatePacket());
		
		server.getPlayerList().saveAllPlayerData();
		server.saveAllWorlds(true);
		
		String worldname=File.separator+server.getFolderName();
		File currentfolder=new File(server.getDataDirectory(),"saves"+worldname);
		File targetfolder=getSavedFolderInDirectory(worldname);
		
		AnvilChunkLoader chunkloader=(AnvilChunkLoader)server.worlds[0].getChunkProvider().chunkLoader;
		incrementSavestates(worldname);
		
		while(chunkloader.getPendingSaveCount()>0) {
		}
		
		FileUtils.copyDirectory(currentfolder, targetfolder);
		CommonProxy.NETWORK.sendToAll(new SavestatePacket());
		isSaving=false;
	}
	
	@Deprecated
	private static void incrementSavestates(String worldname) {
		int[] incr = getInfoValues(getInfoFile(worldname));
		if (incr[0] == 0) {
			saveInfo(getInfoFile(worldname), null);
		} else {
			incr[0]++;
			saveInfo(getInfoFile(worldname), incr);
		}
	}
	@Deprecated
	private static File getInfoFile(String worldname) {
		File file = new File(savestateDirectory, worldname + "-info.txt");
		return file;
	}
	@Deprecated
	public static int[] getInfoValues(File file){
    	int[] out = {0,0};
    	if (file.exists()){
			try {
				BufferedReader buff = new BufferedReader(new FileReader(file));
				String s;
				int i = 0;
				while (i < 100) {
					s = buff.readLine();
					if (s.equalsIgnoreCase("END")) {
						break;
					} else if (s.startsWith("#")) {
						continue;
					} else if (s.startsWith("Total Savestates")) {
						String[] valls = s.split("=");
						out[0] = Integer.parseInt(valls[1]);
					} else if (s.startsWith("Total Rerecords")) {
						String[] valls = s.split("=");
						out[1] = Integer.parseInt(valls[1]);
					}
					i++;
				}
				buff.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
    	}
    	return out;
    }
	@Deprecated
	public static void saveInfo(File file,@Nullable int[] values) {
    	StringBuilder output= new StringBuilder();
    	output.append("#This file was generated by TASTools and diplays info about the usage of savestates!\n\n");
    	if(values==null) {
    		output.append("Total Savestates=1\nTotal Rerecords=0\nEND");
    	}else {
       		output.append("Total Savestates="+Integer.toString(values[0])+"\nTotal Rerecords="+Integer.toString(values[1])+"\nEND");
    	}
    	try{
    		Files.write(output.toString().getBytes(), file);
		} catch (IOException e) {
			e.printStackTrace();
    	}
    }
	/**
	 * Creates the savestate directory in case the user deletes it between savestates
	 */
	private static void createSavestateDirectory() {
		if(!savestateDirectory.exists()) {
			savestateDirectory.mkdir();
		}
	}
	/**
	 * Searches through the savestate folder to look for the next possible savestate foldername
	 * @param worldname
	 * @return targetsavefolder
	 * @throws SavestateException if the found savestates count is greater or equal than 300
	 */
	private static File getSavedFolderInDirectory(String worldname) throws SavestateException {
		int i = 1;
		int limit=300;
		File targetsavefolder=null;
		isSaving=true;
		while (i <= limit) {
			if (i >= limit) {
				isSaving = false;
				throw new SavestateException("Savestatecount is greater or equal than "+limit);
			}
			targetsavefolder = new File(savestateDirectory,worldname + "-Savestate" + Integer.toString(i)+File.separator);
			
			if (!targetsavefolder.exists()) {
				break;
			}
			i++;
		}
		return targetsavefolder;
	}
}